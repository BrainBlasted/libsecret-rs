// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Error {
    Protocol,
    IsLocked,
    NoSuchObject,
    AlreadyExists,
    InvalidFileFormat,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Error::{}",
            match *self {
                Error::Protocol => "Protocol",
                Error::IsLocked => "IsLocked",
                Error::NoSuchObject => "NoSuchObject",
                Error::AlreadyExists => "AlreadyExists",
                Error::InvalidFileFormat => "InvalidFileFormat",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Error {
    type GlibType = ffi::SecretError;

    fn to_glib(&self) -> ffi::SecretError {
        match *self {
            Error::Protocol => ffi::SECRET_ERROR_PROTOCOL,
            Error::IsLocked => ffi::SECRET_ERROR_IS_LOCKED,
            Error::NoSuchObject => ffi::SECRET_ERROR_NO_SUCH_OBJECT,
            Error::AlreadyExists => ffi::SECRET_ERROR_ALREADY_EXISTS,
            Error::InvalidFileFormat => ffi::SECRET_ERROR_INVALID_FILE_FORMAT,
            Error::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretError> for Error {
    fn from_glib(value: ffi::SecretError) -> Self {
        skip_assert_initialized!();
        match value {
            1 => Error::Protocol,
            2 => Error::IsLocked,
            3 => Error::NoSuchObject,
            4 => Error::AlreadyExists,
            5 => Error::InvalidFileFormat,
            value => Error::__Unknown(value),
        }
    }
}

impl StaticType for Error {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Error {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Error {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Error {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SchemaAttributeType {
    String,
    Integer,
    Boolean,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SchemaAttributeType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SchemaAttributeType::{}",
            match *self {
                SchemaAttributeType::String => "String",
                SchemaAttributeType::Integer => "Integer",
                SchemaAttributeType::Boolean => "Boolean",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SchemaAttributeType {
    type GlibType = ffi::SecretSchemaAttributeType;

    fn to_glib(&self) -> ffi::SecretSchemaAttributeType {
        match *self {
            SchemaAttributeType::String => ffi::SECRET_SCHEMA_ATTRIBUTE_STRING,
            SchemaAttributeType::Integer => ffi::SECRET_SCHEMA_ATTRIBUTE_INTEGER,
            SchemaAttributeType::Boolean => ffi::SECRET_SCHEMA_ATTRIBUTE_BOOLEAN,
            SchemaAttributeType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretSchemaAttributeType> for SchemaAttributeType {
    fn from_glib(value: ffi::SecretSchemaAttributeType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SchemaAttributeType::String,
            1 => SchemaAttributeType::Integer,
            2 => SchemaAttributeType::Boolean,
            value => SchemaAttributeType::__Unknown(value),
        }
    }
}

impl StaticType for SchemaAttributeType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_schema_attribute_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SchemaAttributeType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SchemaAttributeType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SchemaAttributeType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SchemaType {
    Note,
    CompatNetwork,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SchemaType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SchemaType::{}",
            match *self {
                SchemaType::Note => "Note",
                SchemaType::CompatNetwork => "CompatNetwork",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SchemaType {
    type GlibType = ffi::SecretSchemaType;

    fn to_glib(&self) -> ffi::SecretSchemaType {
        match *self {
            SchemaType::Note => ffi::SECRET_SCHEMA_TYPE_NOTE,
            SchemaType::CompatNetwork => ffi::SECRET_SCHEMA_TYPE_COMPAT_NETWORK,
            SchemaType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretSchemaType> for SchemaType {
    fn from_glib(value: ffi::SecretSchemaType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SchemaType::Note,
            1 => SchemaType::CompatNetwork,
            value => SchemaType::__Unknown(value),
        }
    }
}

impl StaticType for SchemaType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_schema_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SchemaType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SchemaType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SchemaType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
