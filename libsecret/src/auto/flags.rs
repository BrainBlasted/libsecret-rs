// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use bitflags::bitflags;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

bitflags! {
    pub struct CollectionCreateFlags: u32 {
        const NONE = 0;
    }
}

impl fmt::Display for CollectionCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl ToGlib for CollectionCreateFlags {
    type GlibType = ffi::SecretCollectionCreateFlags;

    fn to_glib(&self) -> ffi::SecretCollectionCreateFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretCollectionCreateFlags> for CollectionCreateFlags {
    unsafe fn from_glib(value: ffi::SecretCollectionCreateFlags) -> CollectionCreateFlags {
        skip_assert_initialized!();
        CollectionCreateFlags::from_bits_truncate(value)
    }
}

impl StaticType for CollectionCreateFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_collection_create_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CollectionCreateFlags {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CollectionCreateFlags {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for CollectionCreateFlags {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct CollectionFlags: u32 {
        const NONE = 0;
        const LOAD_ITEMS = 2;
    }
}

impl fmt::Display for CollectionFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl ToGlib for CollectionFlags {
    type GlibType = ffi::SecretCollectionFlags;

    fn to_glib(&self) -> ffi::SecretCollectionFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretCollectionFlags> for CollectionFlags {
    unsafe fn from_glib(value: ffi::SecretCollectionFlags) -> CollectionFlags {
        skip_assert_initialized!();
        CollectionFlags::from_bits_truncate(value)
    }
}

impl StaticType for CollectionFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_collection_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CollectionFlags {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CollectionFlags {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for CollectionFlags {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct ItemCreateFlags: u32 {
        const NONE = 0;
        const REPLACE = 2;
    }
}

impl fmt::Display for ItemCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl ToGlib for ItemCreateFlags {
    type GlibType = ffi::SecretItemCreateFlags;

    fn to_glib(&self) -> ffi::SecretItemCreateFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretItemCreateFlags> for ItemCreateFlags {
    unsafe fn from_glib(value: ffi::SecretItemCreateFlags) -> ItemCreateFlags {
        skip_assert_initialized!();
        ItemCreateFlags::from_bits_truncate(value)
    }
}

impl StaticType for ItemCreateFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_item_create_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ItemCreateFlags {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ItemCreateFlags {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for ItemCreateFlags {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct ItemFlags: u32 {
        const NONE = 0;
        const LOAD_SECRET = 2;
    }
}

impl fmt::Display for ItemFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl ToGlib for ItemFlags {
    type GlibType = ffi::SecretItemFlags;

    fn to_glib(&self) -> ffi::SecretItemFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretItemFlags> for ItemFlags {
    unsafe fn from_glib(value: ffi::SecretItemFlags) -> ItemFlags {
        skip_assert_initialized!();
        ItemFlags::from_bits_truncate(value)
    }
}

impl StaticType for ItemFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_item_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ItemFlags {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ItemFlags {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for ItemFlags {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct SchemaFlags: u32 {
        const NONE = 0;
        const DONT_MATCH_NAME = 2;
    }
}

impl fmt::Display for SchemaFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl ToGlib for SchemaFlags {
    type GlibType = ffi::SecretSchemaFlags;

    fn to_glib(&self) -> ffi::SecretSchemaFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretSchemaFlags> for SchemaFlags {
    unsafe fn from_glib(value: ffi::SecretSchemaFlags) -> SchemaFlags {
        skip_assert_initialized!();
        SchemaFlags::from_bits_truncate(value)
    }
}

impl StaticType for SchemaFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_schema_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SchemaFlags {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SchemaFlags {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for SchemaFlags {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct SearchFlags: u32 {
        const NONE = 0;
        const ALL = 2;
        const UNLOCK = 4;
        const LOAD_SECRETS = 8;
    }
}

impl fmt::Display for SearchFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl ToGlib for SearchFlags {
    type GlibType = ffi::SecretSearchFlags;

    fn to_glib(&self) -> ffi::SecretSearchFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretSearchFlags> for SearchFlags {
    unsafe fn from_glib(value: ffi::SecretSearchFlags) -> SearchFlags {
        skip_assert_initialized!();
        SearchFlags::from_bits_truncate(value)
    }
}

impl StaticType for SearchFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_search_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SearchFlags {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SearchFlags {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for SearchFlags {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct ServiceFlags: u32 {
        const NONE = 0;
        const OPEN_SESSION = 2;
        const LOAD_COLLECTIONS = 4;
    }
}

impl fmt::Display for ServiceFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl ToGlib for ServiceFlags {
    type GlibType = ffi::SecretServiceFlags;

    fn to_glib(&self) -> ffi::SecretServiceFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SecretServiceFlags> for ServiceFlags {
    unsafe fn from_glib(value: ffi::SecretServiceFlags) -> ServiceFlags {
        skip_assert_initialized!();
        ServiceFlags::from_bits_truncate(value)
    }
}

impl StaticType for ServiceFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::secret_service_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ServiceFlags {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ServiceFlags {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for ServiceFlags {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}
