// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::Collection;
use crate::Prompt;
use crate::ServiceFlags;
use crate::Value;
use glib::object::IsA;
use glib::translate::*;
use std::boxed::Box as Box_;
use std::fmt;
use std::pin::Pin;
use std::ptr;

glib::glib_wrapper! {
    pub struct Service(Object<ffi::SecretService, ffi::SecretServiceClass>) @extends gio::DBusProxy;

    match fn {
        get_type => || ffi::secret_service_get_type(),
    }
}

impl Service {
    pub fn disconnect() {
        assert_initialized_main_thread!();
        unsafe {
            ffi::secret_service_disconnect();
        }
    }

    pub fn get<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<Service, glib::Error>) + Send + 'static,
    >(
        flags: ServiceFlags,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        assert_initialized_main_thread!();
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn get_trampoline<
            Q: FnOnce(Result<Service, glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_get_finish(res, &mut error);
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = get_trampoline::<Q>;
        unsafe {
            ffi::secret_service_get(
                flags.to_glib(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn get_future(
        flags: ServiceFlags,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<Service, glib::Error>> + 'static>> {
        skip_assert_initialized!();
        Box_::pin(gio::GioFuture::new(&(), move |_obj, send| {
            let cancellable = gio::Cancellable::new();
            Self::get(flags, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    pub fn get_sync<P: IsA<gio::Cancellable>>(
        flags: ServiceFlags,
        cancellable: Option<&P>,
    ) -> Result<Service, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_get_sync(
                flags.to_glib(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    pub fn open<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<Service, glib::Error>) + Send + 'static,
    >(
        service_gtype: glib::types::Type,
        service_bus_name: Option<&str>,
        flags: ServiceFlags,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        assert_initialized_main_thread!();
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn open_trampoline<
            Q: FnOnce(Result<Service, glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_open_finish(res, &mut error);
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = open_trampoline::<Q>;
        unsafe {
            ffi::secret_service_open(
                service_gtype.to_glib(),
                service_bus_name.to_glib_none().0,
                flags.to_glib(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn open_future(
        service_gtype: glib::types::Type,
        service_bus_name: Option<&str>,
        flags: ServiceFlags,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<Service, glib::Error>> + 'static>> {
        skip_assert_initialized!();
        let service_bus_name = service_bus_name.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(&(), move |_obj, send| {
            let cancellable = gio::Cancellable::new();
            Self::open(
                service_gtype,
                service_bus_name.as_ref().map(::std::borrow::Borrow::borrow),
                flags,
                Some(&cancellable),
                move |res| {
                    send.resolve(res);
                },
            );

            cancellable
        }))
    }

    pub fn open_sync<P: IsA<gio::Cancellable>>(
        service_gtype: glib::types::Type,
        service_bus_name: Option<&str>,
        flags: ServiceFlags,
        cancellable: Option<&P>,
    ) -> Result<Service, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_open_sync(
                service_gtype.to_glib(),
                service_bus_name.to_glib_none().0,
                flags.to_glib(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }
}

pub const NONE_SERVICE: Option<&Service> = None;

pub trait ServiceExt: 'static {
    //fn clear<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>, callback: Q);

    //
    //fn clear_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    //fn clear_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>) -> Result<(), glib::Error>;

    //fn create_collection_dbus_path<P: IsA<gio::Cancellable>, Q: FnOnce(Result<glib::GString, glib::Error>) + Send + 'static>(&self, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, alias: Option<&str>, flags: CollectionCreateFlags, cancellable: Option<&P>, callback: Q);

    //
    //fn create_collection_dbus_path_future(&self, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, alias: Option<&str>, flags: CollectionCreateFlags) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::GString, glib::Error>> + 'static>>;

    //fn create_collection_dbus_path_sync<P: IsA<gio::Cancellable>>(&self, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, alias: Option<&str>, flags: CollectionCreateFlags, cancellable: Option<&P>) -> Result<glib::GString, glib::Error>;

    //fn create_item_dbus_path<P: IsA<gio::Cancellable>, Q: FnOnce(Result<glib::GString, glib::Error>) + Send + 'static>(&self, collection_path: &str, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, value: &Value, flags: ItemCreateFlags, cancellable: Option<&P>, callback: Q);

    //
    //fn create_item_dbus_path_future(&self, collection_path: &str, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, value: &Value, flags: ItemCreateFlags) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::GString, glib::Error>> + 'static>>;

    //fn create_item_dbus_path_sync<P: IsA<gio::Cancellable>>(&self, collection_path: &str, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, value: &Value, flags: ItemCreateFlags, cancellable: Option<&P>) -> Result<glib::GString, glib::Error>;

    fn decode_dbus_secret(&self, value: &glib::Variant) -> Option<Value>;

    fn delete_item_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        item_path: &str,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn delete_item_dbus_path_future(
        &self,
        item_path: &str,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    fn delete_item_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        item_path: &str,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error>;

    fn encode_dbus_secret(&self, value: &Value) -> Option<glib::Variant>;

    fn ensure_session<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn ensure_session_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    fn ensure_session_sync<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error>;

    fn get_collection_gtype(&self) -> glib::types::Type;

    fn get_collections(&self) -> Vec<Collection>;

    fn get_flags(&self) -> ServiceFlags;

    fn get_item_gtype(&self) -> glib::types::Type;

    fn get_secret_for_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<Option<Value>, glib::Error>) + Send + 'static,
    >(
        &self,
        item_path: &str,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn get_secret_for_dbus_path_future(
        &self,
        item_path: &str,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<Option<Value>, glib::Error>> + 'static>>;

    fn get_secret_for_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        item_path: &str,
        cancellable: Option<&P>,
    ) -> Result<Option<Value>, glib::Error>;

    //fn get_secrets_for_dbus_paths<P: IsA<gio::Cancellable>, Q: FnOnce(Result</*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 1, id: 4 }, glib::Error>) + Send + 'static>(&self, item_paths: &str, cancellable: Option<&P>, callback: Q);

    //
    //fn get_secrets_for_dbus_paths_future(&self, item_paths: &str) -> Pin<Box_<dyn std::future::Future<Output = Result</*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 1, id: 4 }, glib::Error>> + 'static>>;

    //fn get_secrets_for_dbus_paths_sync<P: IsA<gio::Cancellable>>(&self, item_paths: &str, cancellable: Option<&P>) -> Result</*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 1, id: 4 }, glib::Error>;

    fn get_session_algorithms(&self) -> Option<glib::GString>;

    fn get_session_dbus_path(&self) -> Option<glib::GString>;

    fn load_collections<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn load_collections_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    fn load_collections_sync<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error>;

    fn lock<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(i32, Vec<gio::DBusProxy>), glib::Error>) + Send + 'static,
    >(
        &self,
        objects: &[gio::DBusProxy],
        cancellable: Option<&P>,
        callback: Q,
    );

    fn lock_future(
        &self,
        objects: &[gio::DBusProxy],
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<(i32, Vec<gio::DBusProxy>), glib::Error>>
                + 'static,
        >,
    >;

    fn lock_dbus_paths<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(i32, Vec<glib::GString>), glib::Error>) + Send + 'static,
    >(
        &self,
        paths: &str,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn lock_dbus_paths_future(
        &self,
        paths: &str,
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<(i32, Vec<glib::GString>), glib::Error>>
                + 'static,
        >,
    >;

    fn lock_dbus_paths_sync<P: IsA<gio::Cancellable>>(
        &self,
        paths: &str,
        cancellable: Option<&P>,
    ) -> Result<(i32, Vec<glib::GString>), glib::Error>;

    //fn lock_sync<P: IsA<gio::Cancellable>>(&self, objects: &[gio::DBusProxy], cancellable: Option<&P>, locked: /*Unimplemented*/Vec<gio::DBusProxy>) -> Result<i32, glib::Error>;

    //fn lookup<P: IsA<gio::Cancellable>, Q: FnOnce(Result<Value, glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>, callback: Q);

    //
    //fn lookup_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) -> Pin<Box_<dyn std::future::Future<Output = Result<Value, glib::Error>> + 'static>>;

    //fn lookup_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>) -> Result<Value, glib::Error>;

    fn prompt<
        P: IsA<Prompt>,
        Q: IsA<gio::Cancellable>,
        R: FnOnce(Result<glib::Variant, glib::Error>) + Send + 'static,
    >(
        &self,
        prompt: &P,
        return_type: Option<&glib::VariantTy>,
        cancellable: Option<&Q>,
        callback: R,
    );

    fn prompt_future<P: IsA<Prompt> + Clone + 'static>(
        &self,
        prompt: &P,
        return_type: Option<&glib::VariantTy>,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::Variant, glib::Error>> + 'static>>;

    fn prompt_at_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<Option<glib::Variant>, glib::Error>) + Send + 'static,
    >(
        &self,
        prompt_path: &str,
        return_type: Option<&glib::VariantTy>,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn prompt_at_dbus_path_future(
        &self,
        prompt_path: &str,
        return_type: Option<&glib::VariantTy>,
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<Option<glib::Variant>, glib::Error>> + 'static,
        >,
    >;

    fn prompt_at_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        prompt_path: &str,
        cancellable: Option<&P>,
        return_type: Option<&glib::VariantTy>,
    ) -> Result<Option<glib::Variant>, glib::Error>;

    fn prompt_sync<P: IsA<Prompt>, Q: IsA<gio::Cancellable>>(
        &self,
        prompt: &P,
        cancellable: Option<&Q>,
        return_type: &glib::VariantTy,
    ) -> Result<glib::Variant, glib::Error>;

    fn read_alias_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<Option<glib::GString>, glib::Error>) + Send + 'static,
    >(
        &self,
        alias: &str,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn read_alias_dbus_path_future(
        &self,
        alias: &str,
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<Option<glib::GString>, glib::Error>> + 'static,
        >,
    >;

    fn read_alias_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        alias: &str,
        cancellable: Option<&P>,
    ) -> Result<Option<glib::GString>, glib::Error>;

    //fn search<P: IsA<gio::Cancellable>, Q: FnOnce(Result<Vec<Item>, glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, flags: SearchFlags, cancellable: Option<&P>, callback: Q);

    //
    //fn search_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, flags: SearchFlags) -> Pin<Box_<dyn std::future::Future<Output = Result<Vec<Item>, glib::Error>> + 'static>>;

    //fn search_for_dbus_paths<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(Vec<glib::GString>, Vec<glib::GString>), glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>, callback: Q);

    //
    //fn search_for_dbus_paths_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) -> Pin<Box_<dyn std::future::Future<Output = Result<(Vec<glib::GString>, Vec<glib::GString>), glib::Error>> + 'static>>;

    //fn search_for_dbus_paths_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>) -> Result<(Vec<glib::GString>, Vec<glib::GString>), glib::Error>;

    //fn search_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, flags: SearchFlags, cancellable: Option<&P>) -> Result<Vec<Item>, glib::Error>;

    fn set_alias<
        P: IsA<Collection>,
        Q: IsA<gio::Cancellable>,
        R: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        alias: &str,
        collection: Option<&P>,
        cancellable: Option<&Q>,
        callback: R,
    );

    fn set_alias_future<P: IsA<Collection> + Clone + 'static>(
        &self,
        alias: &str,
        collection: Option<&P>,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    fn set_alias_sync<P: IsA<Collection>, Q: IsA<gio::Cancellable>>(
        &self,
        alias: &str,
        collection: Option<&P>,
        cancellable: Option<&Q>,
    ) -> Result<(), glib::Error>;

    fn set_alias_to_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        alias: &str,
        collection_path: Option<&str>,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn set_alias_to_dbus_path_future(
        &self,
        alias: &str,
        collection_path: Option<&str>,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    fn set_alias_to_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        alias: &str,
        collection_path: Option<&str>,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error>;

    //fn store<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, collection: Option<&str>, label: &str, value: &Value, cancellable: Option<&P>, callback: Q);

    //
    //fn store_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, collection: Option<&str>, label: &str, value: &Value) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    //fn store_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, collection: Option<&str>, label: &str, value: &Value, cancellable: Option<&P>) -> Result<(), glib::Error>;

    fn unlock<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(i32, Vec<gio::DBusProxy>), glib::Error>) + Send + 'static,
    >(
        &self,
        objects: &[gio::DBusProxy],
        cancellable: Option<&P>,
        callback: Q,
    );

    fn unlock_future(
        &self,
        objects: &[gio::DBusProxy],
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<(i32, Vec<gio::DBusProxy>), glib::Error>>
                + 'static,
        >,
    >;

    fn unlock_dbus_paths<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(i32, Vec<glib::GString>), glib::Error>) + Send + 'static,
    >(
        &self,
        paths: &str,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn unlock_dbus_paths_future(
        &self,
        paths: &str,
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<(i32, Vec<glib::GString>), glib::Error>>
                + 'static,
        >,
    >;

    fn unlock_dbus_paths_sync<P: IsA<gio::Cancellable>>(
        &self,
        paths: &str,
        cancellable: Option<&P>,
    ) -> Result<(i32, Vec<glib::GString>), glib::Error>;

    //fn unlock_sync<P: IsA<gio::Cancellable>>(&self, objects: &[gio::DBusProxy], cancellable: Option<&P>, unlocked: /*Unimplemented*/Vec<gio::DBusProxy>) -> Result<i32, glib::Error>;
}

impl<O: IsA<Service>> ServiceExt for O {
    //fn clear<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ffi:secret_service_clear() }
    //}

    //
    //fn clear_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

    //let schema = schema.map(ToOwned::to_owned);
    //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    obj.clear(
    //        schema.as_ref().map(::std::borrow::Borrow::borrow),
    //        attributes,
    //        Some(&cancellable),
    //        move |res| {
    //            send.resolve(res);
    //        },
    //    );

    //    cancellable
    //}))
    //}

    //fn clear_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>) -> Result<(), glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_clear_sync() }
    //}

    //fn create_collection_dbus_path<P: IsA<gio::Cancellable>, Q: FnOnce(Result<glib::GString, glib::Error>) + Send + 'static>(&self, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, alias: Option<&str>, flags: CollectionCreateFlags, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ffi:secret_service_create_collection_dbus_path() }
    //}

    //
    //fn create_collection_dbus_path_future(&self, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, alias: Option<&str>, flags: CollectionCreateFlags) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::GString, glib::Error>> + 'static>> {

    //let alias = alias.map(ToOwned::to_owned);
    //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    obj.create_collection_dbus_path(
    //        properties,
    //        alias.as_ref().map(::std::borrow::Borrow::borrow),
    //        flags,
    //        Some(&cancellable),
    //        move |res| {
    //            send.resolve(res);
    //        },
    //    );

    //    cancellable
    //}))
    //}

    //fn create_collection_dbus_path_sync<P: IsA<gio::Cancellable>>(&self, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, alias: Option<&str>, flags: CollectionCreateFlags, cancellable: Option<&P>) -> Result<glib::GString, glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_create_collection_dbus_path_sync() }
    //}

    //fn create_item_dbus_path<P: IsA<gio::Cancellable>, Q: FnOnce(Result<glib::GString, glib::Error>) + Send + 'static>(&self, collection_path: &str, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, value: &Value, flags: ItemCreateFlags, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ffi:secret_service_create_item_dbus_path() }
    //}

    //
    //fn create_item_dbus_path_future(&self, collection_path: &str, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, value: &Value, flags: ItemCreateFlags) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::GString, glib::Error>> + 'static>> {

    //let collection_path = String::from(collection_path);
    //let value = value.clone();
    //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    obj.create_item_dbus_path(
    //        &collection_path,
    //        properties,
    //        &value,
    //        flags,
    //        Some(&cancellable),
    //        move |res| {
    //            send.resolve(res);
    //        },
    //    );

    //    cancellable
    //}))
    //}

    //fn create_item_dbus_path_sync<P: IsA<gio::Cancellable>>(&self, collection_path: &str, properties: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 194 }, value: &Value, flags: ItemCreateFlags, cancellable: Option<&P>) -> Result<glib::GString, glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_create_item_dbus_path_sync() }
    //}

    fn decode_dbus_secret(&self, value: &glib::Variant) -> Option<Value> {
        unsafe {
            from_glib_full(ffi::secret_service_decode_dbus_secret(
                self.as_ref().to_glib_none().0,
                value.to_glib_none().0,
            ))
        }
    }

    fn delete_item_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        item_path: &str,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn delete_item_dbus_path_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_delete_item_dbus_path_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = delete_item_dbus_path_trampoline::<Q>;
        unsafe {
            ffi::secret_service_delete_item_dbus_path(
                self.as_ref().to_glib_none().0,
                item_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn delete_item_dbus_path_future(
        &self,
        item_path: &str,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let item_path = String::from(item_path);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.delete_item_dbus_path(&item_path, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn delete_item_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        item_path: &str,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_delete_item_dbus_path_sync(
                self.as_ref().to_glib_none().0,
                item_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn encode_dbus_secret(&self, value: &Value) -> Option<glib::Variant> {
        unsafe {
            from_glib_none(ffi::secret_service_encode_dbus_secret(
                self.as_ref().to_glib_none().0,
                value.to_glib_none().0,
            ))
        }
    }

    fn ensure_session<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn ensure_session_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_ensure_session_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = ensure_session_trampoline::<Q>;
        unsafe {
            ffi::secret_service_ensure_session(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn ensure_session_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.ensure_session(Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn ensure_session_sync<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_ensure_session_sync(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn get_collection_gtype(&self) -> glib::types::Type {
        unsafe {
            from_glib(ffi::secret_service_get_collection_gtype(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_collections(&self) -> Vec<Collection> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::secret_service_get_collections(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_flags(&self) -> ServiceFlags {
        unsafe {
            from_glib(ffi::secret_service_get_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_item_gtype(&self) -> glib::types::Type {
        unsafe {
            from_glib(ffi::secret_service_get_item_gtype(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_secret_for_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<Option<Value>, glib::Error>) + Send + 'static,
    >(
        &self,
        item_path: &str,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn get_secret_for_dbus_path_trampoline<
            Q: FnOnce(Result<Option<Value>, glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_get_secret_for_dbus_path_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = get_secret_for_dbus_path_trampoline::<Q>;
        unsafe {
            ffi::secret_service_get_secret_for_dbus_path(
                self.as_ref().to_glib_none().0,
                item_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn get_secret_for_dbus_path_future(
        &self,
        item_path: &str,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<Option<Value>, glib::Error>> + 'static>>
    {
        let item_path = String::from(item_path);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.get_secret_for_dbus_path(&item_path, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn get_secret_for_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        item_path: &str,
        cancellable: Option<&P>,
    ) -> Result<Option<Value>, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_get_secret_for_dbus_path_sync(
                self.as_ref().to_glib_none().0,
                item_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    //fn get_secrets_for_dbus_paths<P: IsA<gio::Cancellable>, Q: FnOnce(Result</*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 1, id: 4 }, glib::Error>) + Send + 'static>(&self, item_paths: &str, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ffi:secret_service_get_secrets_for_dbus_paths() }
    //}

    //
    //fn get_secrets_for_dbus_paths_future(&self, item_paths: &str) -> Pin<Box_<dyn std::future::Future<Output = Result</*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 1, id: 4 }, glib::Error>> + 'static>> {

    //let item_paths = String::from(item_paths);
    //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    obj.get_secrets_for_dbus_paths(
    //        &item_paths,
    //        Some(&cancellable),
    //        move |res| {
    //            send.resolve(res);
    //        },
    //    );

    //    cancellable
    //}))
    //}

    //fn get_secrets_for_dbus_paths_sync<P: IsA<gio::Cancellable>>(&self, item_paths: &str, cancellable: Option<&P>) -> Result</*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 1, id: 4 }, glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_get_secrets_for_dbus_paths_sync() }
    //}

    fn get_session_algorithms(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::secret_service_get_session_algorithms(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_session_dbus_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::secret_service_get_session_dbus_path(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn load_collections<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn load_collections_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_load_collections_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = load_collections_trampoline::<Q>;
        unsafe {
            ffi::secret_service_load_collections(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn load_collections_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.load_collections(Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn load_collections_sync<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_load_collections_sync(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn lock<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(i32, Vec<gio::DBusProxy>), glib::Error>) + Send + 'static,
    >(
        &self,
        objects: &[gio::DBusProxy],
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn lock_trampoline<
            Q: FnOnce(Result<(i32, Vec<gio::DBusProxy>), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let mut locked = ptr::null_mut();
            let ret = ffi::secret_service_lock_finish(
                _source_object as *mut _,
                res,
                &mut locked,
                &mut error,
            );
            let result = if error.is_null() {
                Ok((ret, FromGlibPtrContainer::from_glib_full(locked)))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = lock_trampoline::<Q>;
        unsafe {
            ffi::secret_service_lock(
                self.as_ref().to_glib_none().0,
                objects.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn lock_future(
        &self,
        objects: &[gio::DBusProxy],
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<(i32, Vec<gio::DBusProxy>), glib::Error>>
                + 'static,
        >,
    > {
        let objects = objects.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.lock(&objects, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn lock_dbus_paths<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(i32, Vec<glib::GString>), glib::Error>) + Send + 'static,
    >(
        &self,
        paths: &str,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn lock_dbus_paths_trampoline<
            Q: FnOnce(Result<(i32, Vec<glib::GString>), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let mut locked = ptr::null_mut();
            let ret = ffi::secret_service_lock_dbus_paths_finish(
                _source_object as *mut _,
                res,
                &mut locked,
                &mut error,
            );
            let result = if error.is_null() {
                Ok((ret, FromGlibPtrContainer::from_glib_full(locked)))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = lock_dbus_paths_trampoline::<Q>;
        unsafe {
            ffi::secret_service_lock_dbus_paths(
                self.as_ref().to_glib_none().0,
                paths.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn lock_dbus_paths_future(
        &self,
        paths: &str,
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<(i32, Vec<glib::GString>), glib::Error>>
                + 'static,
        >,
    > {
        let paths = String::from(paths);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.lock_dbus_paths(&paths, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn lock_dbus_paths_sync<P: IsA<gio::Cancellable>>(
        &self,
        paths: &str,
        cancellable: Option<&P>,
    ) -> Result<(i32, Vec<glib::GString>), glib::Error> {
        unsafe {
            let mut locked = ptr::null_mut();
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_lock_dbus_paths_sync(
                self.as_ref().to_glib_none().0,
                paths.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut locked,
                &mut error,
            );
            if error.is_null() {
                Ok((ret, FromGlibPtrContainer::from_glib_full(locked)))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    //fn lock_sync<P: IsA<gio::Cancellable>>(&self, objects: &[gio::DBusProxy], cancellable: Option<&P>, locked: /*Unimplemented*/Vec<gio::DBusProxy>) -> Result<i32, glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_lock_sync() }
    //}

    //fn lookup<P: IsA<gio::Cancellable>, Q: FnOnce(Result<Value, glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ffi:secret_service_lookup() }
    //}

    //
    //fn lookup_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) -> Pin<Box_<dyn std::future::Future<Output = Result<Value, glib::Error>> + 'static>> {

    //let schema = schema.map(ToOwned::to_owned);
    //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    obj.lookup(
    //        schema.as_ref().map(::std::borrow::Borrow::borrow),
    //        attributes,
    //        Some(&cancellable),
    //        move |res| {
    //            send.resolve(res);
    //        },
    //    );

    //    cancellable
    //}))
    //}

    //fn lookup_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>) -> Result<Value, glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_lookup_sync() }
    //}

    fn prompt<
        P: IsA<Prompt>,
        Q: IsA<gio::Cancellable>,
        R: FnOnce(Result<glib::Variant, glib::Error>) + Send + 'static,
    >(
        &self,
        prompt: &P,
        return_type: Option<&glib::VariantTy>,
        cancellable: Option<&Q>,
        callback: R,
    ) {
        let user_data: Box_<R> = Box_::new(callback);
        unsafe extern "C" fn prompt_trampoline<
            R: FnOnce(Result<glib::Variant, glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_prompt_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<R> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = prompt_trampoline::<R>;
        unsafe {
            ffi::secret_service_prompt(
                self.as_ref().to_glib_none().0,
                prompt.as_ref().to_glib_none().0,
                return_type.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn prompt_future<P: IsA<Prompt> + Clone + 'static>(
        &self,
        prompt: &P,
        return_type: Option<&glib::VariantTy>,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::Variant, glib::Error>> + 'static>>
    {
        let prompt = prompt.clone();
        let return_type = return_type.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.prompt(
                &prompt,
                return_type.as_ref().map(::std::borrow::Borrow::borrow),
                Some(&cancellable),
                move |res| {
                    send.resolve(res);
                },
            );

            cancellable
        }))
    }

    fn prompt_at_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<Option<glib::Variant>, glib::Error>) + Send + 'static,
    >(
        &self,
        prompt_path: &str,
        return_type: Option<&glib::VariantTy>,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn prompt_at_dbus_path_trampoline<
            Q: FnOnce(Result<Option<glib::Variant>, glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_prompt_at_dbus_path_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = prompt_at_dbus_path_trampoline::<Q>;
        unsafe {
            ffi::secret_service_prompt_at_dbus_path(
                self.as_ref().to_glib_none().0,
                prompt_path.to_glib_none().0,
                return_type.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn prompt_at_dbus_path_future(
        &self,
        prompt_path: &str,
        return_type: Option<&glib::VariantTy>,
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<Option<glib::Variant>, glib::Error>> + 'static,
        >,
    > {
        let prompt_path = String::from(prompt_path);
        let return_type = return_type.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.prompt_at_dbus_path(
                &prompt_path,
                return_type.as_ref().map(::std::borrow::Borrow::borrow),
                Some(&cancellable),
                move |res| {
                    send.resolve(res);
                },
            );

            cancellable
        }))
    }

    fn prompt_at_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        prompt_path: &str,
        cancellable: Option<&P>,
        return_type: Option<&glib::VariantTy>,
    ) -> Result<Option<glib::Variant>, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_prompt_at_dbus_path_sync(
                self.as_ref().to_glib_none().0,
                prompt_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                return_type.to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn prompt_sync<P: IsA<Prompt>, Q: IsA<gio::Cancellable>>(
        &self,
        prompt: &P,
        cancellable: Option<&Q>,
        return_type: &glib::VariantTy,
    ) -> Result<glib::Variant, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_prompt_sync(
                self.as_ref().to_glib_none().0,
                prompt.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                return_type.to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn read_alias_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<Option<glib::GString>, glib::Error>) + Send + 'static,
    >(
        &self,
        alias: &str,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn read_alias_dbus_path_trampoline<
            Q: FnOnce(Result<Option<glib::GString>, glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_read_alias_dbus_path_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = read_alias_dbus_path_trampoline::<Q>;
        unsafe {
            ffi::secret_service_read_alias_dbus_path(
                self.as_ref().to_glib_none().0,
                alias.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn read_alias_dbus_path_future(
        &self,
        alias: &str,
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<Option<glib::GString>, glib::Error>> + 'static,
        >,
    > {
        let alias = String::from(alias);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.read_alias_dbus_path(&alias, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn read_alias_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        alias: &str,
        cancellable: Option<&P>,
    ) -> Result<Option<glib::GString>, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_read_alias_dbus_path_sync(
                self.as_ref().to_glib_none().0,
                alias.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    //fn search<P: IsA<gio::Cancellable>, Q: FnOnce(Result<Vec<Item>, glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, flags: SearchFlags, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ffi:secret_service_search() }
    //}

    //
    //fn search_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, flags: SearchFlags) -> Pin<Box_<dyn std::future::Future<Output = Result<Vec<Item>, glib::Error>> + 'static>> {

    //let schema = schema.map(ToOwned::to_owned);
    //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    obj.search(
    //        schema.as_ref().map(::std::borrow::Borrow::borrow),
    //        attributes,
    //        flags,
    //        Some(&cancellable),
    //        move |res| {
    //            send.resolve(res);
    //        },
    //    );

    //    cancellable
    //}))
    //}

    //fn search_for_dbus_paths<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(Vec<glib::GString>, Vec<glib::GString>), glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ffi:secret_service_search_for_dbus_paths() }
    //}

    //
    //fn search_for_dbus_paths_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) -> Pin<Box_<dyn std::future::Future<Output = Result<(Vec<glib::GString>, Vec<glib::GString>), glib::Error>> + 'static>> {

    //let schema = schema.map(ToOwned::to_owned);
    //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    obj.search_for_dbus_paths(
    //        schema.as_ref().map(::std::borrow::Borrow::borrow),
    //        attributes,
    //        Some(&cancellable),
    //        move |res| {
    //            send.resolve(res);
    //        },
    //    );

    //    cancellable
    //}))
    //}

    //fn search_for_dbus_paths_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: Option<&P>) -> Result<(Vec<glib::GString>, Vec<glib::GString>), glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_search_for_dbus_paths_sync() }
    //}

    //fn search_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, flags: SearchFlags, cancellable: Option<&P>) -> Result<Vec<Item>, glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_search_sync() }
    //}

    fn set_alias<
        P: IsA<Collection>,
        Q: IsA<gio::Cancellable>,
        R: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        alias: &str,
        collection: Option<&P>,
        cancellable: Option<&Q>,
        callback: R,
    ) {
        let user_data: Box_<R> = Box_::new(callback);
        unsafe extern "C" fn set_alias_trampoline<
            R: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_set_alias_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<R> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = set_alias_trampoline::<R>;
        unsafe {
            ffi::secret_service_set_alias(
                self.as_ref().to_glib_none().0,
                alias.to_glib_none().0,
                collection.map(|p| p.as_ref()).to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn set_alias_future<P: IsA<Collection> + Clone + 'static>(
        &self,
        alias: &str,
        collection: Option<&P>,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let alias = String::from(alias);
        let collection = collection.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.set_alias(
                &alias,
                collection.as_ref().map(::std::borrow::Borrow::borrow),
                Some(&cancellable),
                move |res| {
                    send.resolve(res);
                },
            );

            cancellable
        }))
    }

    fn set_alias_sync<P: IsA<Collection>, Q: IsA<gio::Cancellable>>(
        &self,
        alias: &str,
        collection: Option<&P>,
        cancellable: Option<&Q>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_set_alias_sync(
                self.as_ref().to_glib_none().0,
                alias.to_glib_none().0,
                collection.map(|p| p.as_ref()).to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn set_alias_to_dbus_path<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        alias: &str,
        collection_path: Option<&str>,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn set_alias_to_dbus_path_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_set_alias_to_dbus_path_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = set_alias_to_dbus_path_trampoline::<Q>;
        unsafe {
            ffi::secret_service_set_alias_to_dbus_path(
                self.as_ref().to_glib_none().0,
                alias.to_glib_none().0,
                collection_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn set_alias_to_dbus_path_future(
        &self,
        alias: &str,
        collection_path: Option<&str>,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let alias = String::from(alias);
        let collection_path = collection_path.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.set_alias_to_dbus_path(
                &alias,
                collection_path.as_ref().map(::std::borrow::Borrow::borrow),
                Some(&cancellable),
                move |res| {
                    send.resolve(res);
                },
            );

            cancellable
        }))
    }

    fn set_alias_to_dbus_path_sync<P: IsA<gio::Cancellable>>(
        &self,
        alias: &str,
        collection_path: Option<&str>,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ffi::secret_service_set_alias_to_dbus_path_sync(
                self.as_ref().to_glib_none().0,
                alias.to_glib_none().0,
                collection_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    //fn store<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + Send + 'static>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, collection: Option<&str>, label: &str, value: &Value, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ffi:secret_service_store() }
    //}

    //
    //fn store_future(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, collection: Option<&str>, label: &str, value: &Value) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

    //let schema = schema.map(ToOwned::to_owned);
    //let collection = collection.map(ToOwned::to_owned);
    //let label = String::from(label);
    //let value = value.clone();
    //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    obj.store(
    //        schema.as_ref().map(::std::borrow::Borrow::borrow),
    //        attributes,
    //        collection.as_ref().map(::std::borrow::Borrow::borrow),
    //        &label,
    //        &value,
    //        Some(&cancellable),
    //        move |res| {
    //            send.resolve(res);
    //        },
    //    );

    //    cancellable
    //}))
    //}

    //fn store_sync<P: IsA<gio::Cancellable>>(&self, schema: Option<&Schema>, attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, collection: Option<&str>, label: &str, value: &Value, cancellable: Option<&P>) -> Result<(), glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_store_sync() }
    //}

    fn unlock<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(i32, Vec<gio::DBusProxy>), glib::Error>) + Send + 'static,
    >(
        &self,
        objects: &[gio::DBusProxy],
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn unlock_trampoline<
            Q: FnOnce(Result<(i32, Vec<gio::DBusProxy>), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let mut unlocked = ptr::null_mut();
            let ret = ffi::secret_service_unlock_finish(
                _source_object as *mut _,
                res,
                &mut unlocked,
                &mut error,
            );
            let result = if error.is_null() {
                Ok((ret, FromGlibPtrContainer::from_glib_full(unlocked)))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = unlock_trampoline::<Q>;
        unsafe {
            ffi::secret_service_unlock(
                self.as_ref().to_glib_none().0,
                objects.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn unlock_future(
        &self,
        objects: &[gio::DBusProxy],
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<(i32, Vec<gio::DBusProxy>), glib::Error>>
                + 'static,
        >,
    > {
        let objects = objects.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.unlock(&objects, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn unlock_dbus_paths<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(i32, Vec<glib::GString>), glib::Error>) + Send + 'static,
    >(
        &self,
        paths: &str,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn unlock_dbus_paths_trampoline<
            Q: FnOnce(Result<(i32, Vec<glib::GString>), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let mut unlocked = ptr::null_mut();
            let ret = ffi::secret_service_unlock_dbus_paths_finish(
                _source_object as *mut _,
                res,
                &mut unlocked,
                &mut error,
            );
            let result = if error.is_null() {
                Ok((ret, FromGlibPtrContainer::from_glib_full(unlocked)))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = unlock_dbus_paths_trampoline::<Q>;
        unsafe {
            ffi::secret_service_unlock_dbus_paths(
                self.as_ref().to_glib_none().0,
                paths.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn unlock_dbus_paths_future(
        &self,
        paths: &str,
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<(i32, Vec<glib::GString>), glib::Error>>
                + 'static,
        >,
    > {
        let paths = String::from(paths);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.unlock_dbus_paths(&paths, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn unlock_dbus_paths_sync<P: IsA<gio::Cancellable>>(
        &self,
        paths: &str,
        cancellable: Option<&P>,
    ) -> Result<(i32, Vec<glib::GString>), glib::Error> {
        unsafe {
            let mut unlocked = ptr::null_mut();
            let mut error = ptr::null_mut();
            let ret = ffi::secret_service_unlock_dbus_paths_sync(
                self.as_ref().to_glib_none().0,
                paths.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut unlocked,
                &mut error,
            );
            if error.is_null() {
                Ok((ret, FromGlibPtrContainer::from_glib_full(unlocked)))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    //fn unlock_sync<P: IsA<gio::Cancellable>>(&self, objects: &[gio::DBusProxy], cancellable: Option<&P>, unlocked: /*Unimplemented*/Vec<gio::DBusProxy>) -> Result<i32, glib::Error> {
    //    unsafe { TODO: call ffi:secret_service_unlock_sync() }
    //}
}

impl fmt::Display for Service {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Service")
    }
}
